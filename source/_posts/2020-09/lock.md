---
title: 悲观锁 & 乐观锁
tags: SQL
date: 2020-09-09 13:48:34
---

## 悲观锁

**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**

> Java中 `synchronized` 和 `ReentrantLock` 等独占锁就是悲观锁思想的实现。

- 适合多写环境



## 乐观锁

- 不上锁
- 更新前判断数据是否被更新
- 使用版本号机制和 CAS 算法
- 适合多读少写环境

> 在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。



## 总结

**CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**

1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。



作者：JavaGuide

链接：https://juejin.im/post/6844903639207641096

来源：掘金

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

